=head1 Perlude tutorial

=head2 Motivation

While programming in Perl, I missed the awesomeness of the shell pipe for a while. Learning haskell and clojure, i discovered they have similar concepts and figured out how perl can easily have it.

Perlude bring the pipe concept to perl, stealing keywords from the haskell prelude.

=head2 Why is pipe so cool ?

Pipe was invented to bind programs together, its inventor (Doug Mc Ilroy) also ennounced the KISS (keep it simple stupid) principles of writing unix programs.

Some programs, like ls generate some content by probing their environement or by computing something. let's call them generators. others apply some changes on the standard input content and write the result of the application on standard output. those commands are called filters. 

Connecting the stdout of programs to stdin of others,  Pipe allow 2 types of compositions

    G | F => G 
    F | F => F

=over 2

=item do one thing and do it well

=item ???

=item which communicate with others

=back

So it's very easy to combine commands that are really reusable



As result, the parts of your shell scripts are easier to write and reuse. This is because 

=over 2

=item pipes make things easy to compose, removing loads of loops

=item pipe is "on demand", which means that the computation will stop as soon as one of the elements of the composition reached achievement

=back

As example:  What are the 5 first naturals containing a 3?

A perl implementation would be:

    for
    ( my $_=0, my $count=0
    ; $count <= 5
    ; $_++ )
    { if (/3/) { $count++; say } }

The shell counterpart would be

    nat () { while {true} { print $[i++] } }
    nat | grep 3 | head -n5

There are things to understand about the shell elegance:

=over 2

=item there is no need of a counter variable, neither a for loop: head is the single command which handles it for you.

=item the implementation of nat is bare simple: you just focus on your nat problem, you don't care how many elements the filter could need.

=item you added nat to your toolkit, it's much more pain to resuse it in perl ... before Perlude

=back

also, it's easy to create a new function 'top5' by passsing a an argument to head (looks like a partial application):

    top5 () { head -n5 }
    contains3 () { grep 3 }
    nat | contains3 | top5

No perl builtin provide this power.

=head2 I can haz nat in perl ? 

nat is the basic closure exemple:

    my $nat = sub { state $x=0; $x++ }

a reusable way to write it would be: 

    sub nat_from {
        my $x = shift;
        sub { $x++ }
    }

    sub nat { nat_from 0 }

but it didn't help so much while we don't have a head function that can read 5 elements. now Perlude come to the rescue! the perlude version of our problem is



=head2 Perlude


Perlude is a set of functions that takes closures as arguments, and returns others

    now { ta}


=head2 take $n, $c

returns










